/*
This script searches for merged commits to Official-MoonDao repositories by a specific user within a given date range.  Optionally, it can export the raw GitHub data or generate an AI summary of the contributions and save it to a file.

WIP: The AI summary is generated using OpenAI API, every 50 commits are processed in a batch.  The final summary is generated by combining the summaries of all batches.

OPENAI_API_KEY is required for AI summary.
https://platform.openai.com/account/api-keys

GITHUB_TOKEN is required for GitHub API.
https://github.com/settings/tokens

Usage:
npx ts-node contribution-summary.ts <username> <start-date> <end-date> [--export|--ai]

Example:
npx ts-node contribution-summary.ts namedotget 2025-04-01 2025-09-30 --ai

--export: Save raw GitHub data to generated/ folder
--ai: Generate AI summary and save to generated/ folder
*/
import { config } from 'dotenv'
import { writeFileSync } from 'fs'
import { join } from 'path'

config({ path: join(__dirname, '../../.env.local') })

interface GitHubCommit {
  sha: string
  commit: {
    message: string
    author: {
      name: string
      email: string
      date: string
    }
  }
  html_url: string
  repository?: {
    full_name: string
  }
}

interface SearchResult {
  commits: GitHubCommit[]
}

const GITHUB_TOKEN = process.env.GITHUB_TOKEN
const OPENAI_API_KEY = process.env.OPENAI_API_KEY
const GITHUB_BASE_URL = 'https://api.github.com'

if (!GITHUB_TOKEN) {
  throw new Error('GITHUB_TOKEN environment variable is required')
}

async function makeRequest(url: string): Promise<any> {
  const response = await fetch(url, {
    headers: {
      Authorization: `token ${GITHUB_TOKEN}`,
      Accept: 'application/vnd.github.v3+json',
      'User-Agent': 'MoonDAO-Contribution-Summary',
    },
  })

  if (!response.ok) {
    throw new Error(
      `GitHub API request failed: ${response.status} ${response.statusText}`
    )
  }

  return response.json()
}

function formatDate(dateString: string): string {
  return new Date(dateString).toISOString().split('T')[0]
}

async function searchCommits(
  username: string,
  startDate: string,
  endDate: string
): Promise<GitHubCommit[]> {
  console.log(
    `üîç Searching for merged commits by ${username} from ${startDate} to ${endDate}...`
  )

  const query = `author:${username} committer-date:${startDate}..${endDate} org:Official-MoonDao is:merged`
  let allCommits: GitHubCommit[] = []
  let page = 1
  const perPage = 100

  try {
    while (true) {
      const url = `${GITHUB_BASE_URL}/search/commits?q=${encodeURIComponent(
        query
      )}&sort=committer-date&order=desc&per_page=${perPage}&page=${page}`

      const data = await makeRequest(url)

      if (data.items.length === 0) {
        break
      }

      allCommits = allCommits.concat(data.items)

      if (data.items.length < perPage) {
        break
      }

      page++

      await new Promise((resolve) => setTimeout(resolve, 100))
    }

    console.log(`‚úÖ Found ${allCommits.length} commits total`)
    return allCommits
  } catch (error) {
    console.error('‚ùå Error searching commits:', error)
    return allCommits
  }
}

async function getContributionSummary(
  username: string,
  startDate: string,
  endDate: string
): Promise<SearchResult> {
  console.log(`\nüìä Getting contribution summary for ${username}`)
  console.log(`üìÖ Date range: ${startDate} to ${endDate}\n`)

  const commits = await searchCommits(username, startDate, endDate)

  return { commits }
}

function displayResults(
  result: SearchResult,
  username: string,
  exportFormat: boolean = false
): void {
  if (exportFormat) {
    displayExportFormat(result, username)
  } else {
    displayStandardFormat(result, username)
  }
}

function saveExportData(
  result: SearchResult,
  username: string,
  startDate: string,
  endDate: string
): void {
  try {
    const exportData = generateExportText(result, username)

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const filename = `github-data-${username}-${startDate}-to-${endDate}-${timestamp}.md`
    const filepath = join(__dirname, '../generated', filename)

    const report = `# GitHub Contribution Data

**Developer:** ${username}  
**Period:** ${startDate} to ${endDate}  
**Generated:** ${new Date().toLocaleString()}  
**Type:** Raw GitHub Data Export

---

${exportData}
`
    writeFileSync(filepath, report, 'utf8')

    console.log(`\n‚úÖ GitHub data saved to: ${filepath}`)
    console.log(`üìä Export completed successfully!`)
  } catch (error) {
    console.error('‚ùå Error saving export data:', error)
    throw error
  }
}

function displayStandardFormat(result: SearchResult, username: string): void {
  console.log('\n' + '='.repeat(80))
  console.log(`üìà CONTRIBUTION SUMMARY FOR ${username.toUpperCase()}`)
  console.log('='.repeat(80))

  console.log(`\nüíæ COMMITS (${result.commits.length} total):`)
  console.log('-'.repeat(50))

  if (result.commits.length === 0) {
    console.log('   No commits found in the specified date range.')
  } else {
    result.commits.forEach((commit, index) => {
      console.log(`\n${index + 1}. ${commit.commit.message.split('\n')[0]}`)
      console.log(`   üìÖ Date: ${formatDate(commit.commit.author.date)}`)
      console.log(`   üîó URL: ${commit.html_url}`)
      console.log(`   üîë SHA: ${commit.sha.substring(0, 7)}`)
      if (commit.commit.message.includes('\n')) {
        const fullMessage =
          commit.commit.message.length > 300
            ? commit.commit.message.substring(0, 300) + '...'
            : commit.commit.message
        console.log(
          `   üìù Full message: ${fullMessage.replace(/\n/g, '\n       ')}`
        )
      }
    })
  }

  console.log('\n' + '='.repeat(80))
  console.log('üìä STATISTICS:')
  console.log('='.repeat(80))
  console.log(`Total Commits: ${result.commits.length}`)
}

function displayExportFormat(result: SearchResult, username: string): void {
  console.log(`GitHub Contribution Summary for ${username}`)
  console.log(`=====================================\n`)

  console.log(`COMMITS (${result.commits.length} total):\n`)

  if (result.commits.length === 0) {
    console.log('No commits found.\n')
  } else {
    result.commits.forEach((commit, index) => {
      console.log(`${index + 1}. ${commit.commit.message.replace(/\n/g, ' ')}`)
      console.log(`   Date: ${formatDate(commit.commit.author.date)}`)
      console.log(`   SHA: ${commit.sha.substring(0, 7)}`)
      console.log('')
    })
  }

  console.log(`SUMMARY:`)
  console.log(`- Total Commits: ${result.commits.length}`)
}

function generateExportText(result: SearchResult, username: string): string {
  let output = `GitHub Contribution Summary for ${username}\n`
  output += `=====================================\n\n`

  output += `COMMITS (${result.commits.length} total):\n\n`

  if (result.commits.length === 0) {
    output += 'No commits found.\n\n'
  } else {
    result.commits.forEach((commit, index) => {
      output += `${index + 1}. ${commit.commit.message.replace(/\n/g, ' ')}\n`
      output += `   Date: ${formatDate(commit.commit.author.date)}\n`
      output += `   SHA: ${commit.sha.substring(0, 7)}\n`
      output += '\n'
    })
  }

  output += `SUMMARY:\n`
  output += `- Total Commits: ${result.commits.length}\n`

  return output
}

function createBatches(
  result: SearchResult,
  batchSize: number = 50
): Array<{ commits: GitHubCommit[] }> {
  const batches = []
  const totalCommits = result.commits.length

  let commitIndex = 0

  while (commitIndex < totalCommits) {
    const batch = {
      commits: result.commits.slice(
        commitIndex,
        Math.min(commitIndex + batchSize, totalCommits)
      ),
    }

    batches.push(batch)
    commitIndex += batchSize
  }

  return batches
}

function generateBatchText(
  batch: { commits: GitHubCommit[] },
  username: string
): string {
  let output = `Batch Contribution Data for ${username}\n`
  output += `=====================================\n\n`

  output += `COMMITS (${batch.commits.length} in this batch):\n\n`

  if (batch.commits.length === 0) {
    output += 'No commits in this batch.\n\n'
  } else {
    batch.commits.forEach((commit, index) => {
      const message = commit.commit.message.replace(/\n/g, ' ')
      output += `${index + 1}. ${message}\n`
      output += `   Date: ${formatDate(
        commit.commit.author.date
      )} | SHA: ${commit.sha.substring(0, 7)}\n`
      output += '\n'
    })
  }

  return output
}

async function callOpenAIForBatch(
  batchData: string,
  batchNumber: number,
  totalBatches: number,
  username: string
): Promise<string> {
  console.log(
    `ü§ñ Generating summary for batch ${batchNumber}/${totalBatches}...`
  )

  const prompt = `Please analyze this batch of merged GitHub commits and provide a focused summary. This is batch ${batchNumber} of ${totalBatches} total batches for ${username}.

Focus on:
1. **Key Contributions**: What were the most significant commits in this batch?
2. **Technical Areas**: What technologies, frameworks, or systems were worked on?
3. **Themes**: What patterns or focus areas do you see?
4. **Impact**: What problems were solved or features were added?

Commit data for this batch:

${batchData}

Please provide a concise but comprehensive summary of this batch. This will be combined with other batch summaries later.`

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        max_tokens: 1500,
        temperature: 0.7,
      }),
    })

    if (!response.ok) {
      const errorBody = await response.text()
      console.error('OpenAI API Error Details:', errorBody)
      throw new Error(
        `OpenAI API request failed: ${response.status} ${response.statusText} - ${errorBody}`
      )
    }

    const data = await response.json()
    return data.choices[0].message.content
  } catch (error) {
    console.error(`‚ùå Error calling OpenAI for batch ${batchNumber}:`, error)
    throw error
  }
}

async function callOpenAIForFinalSummary(
  batchSummaries: string[],
  username: string,
  startDate: string,
  endDate: string,
  totalStats: { prs: number; commits: number; mergedPRs: number }
): Promise<string> {
  console.log('üéØ Generating final comprehensive summary...')

  const prompt = `Please create a comprehensive final summary based on these batch summaries of merged GitHub commits for ${username} from ${startDate} to ${endDate}.

STATISTICS:
- Total Commits: ${totalStats.commits}

BATCH SUMMARIES:
${batchSummaries
  .map((summary, index) => `\n--- BATCH ${index + 1} SUMMARY ---\n${summary}`)
  .join('\n')}

Please provide a comprehensive final summary that:

1. **Executive Overview**: High-level summary of what was accomplished during this entire period
2. **Key Achievements**: Most significant contributions and milestones
3. **Technical Focus Areas**: Main technologies, frameworks, and systems worked on
4. **Themes and Patterns**: Recurring themes and focus areas across all contributions
5. **Impact and Value**: Problems solved, features added, and overall impact
6. **Notable Highlights**: Standout contributions that deserve special mention

This summary should be professional, comprehensive, and suitable for performance reviews or project reports. Synthesize insights from all batches to provide a complete picture of the work accomplished.`

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        max_tokens: 3000,
        temperature: 0.7,
      }),
    })

    if (!response.ok) {
      const errorBody = await response.text()
      console.error('OpenAI API Error Details:', errorBody)
      throw new Error(
        `OpenAI API request failed: ${response.status} ${response.statusText} - ${errorBody}`
      )
    }

    const data = await response.json()
    return data.choices[0].message.content
  } catch (error) {
    console.error('‚ùå Error calling OpenAI for final summary:', error)
    throw error
  }
}

async function generateAndSaveSummary(
  result: SearchResult,
  username: string,
  startDate: string,
  endDate: string
): Promise<void> {
  try {
    const fullContributionData = generateExportText(result, username)

    console.log(`üìä Processing ${result.commits.length} commits...`)

    const batches = createBatches(result, 50) // 50 items per batch

    const concurrencyLimit = 20 // Process 20 batches at a time to respect rate limits
    const batchSummaries: string[] = new Array(batches.length)

    for (let i = 0; i < batches.length; i += concurrencyLimit) {
      const chunk = batches.slice(i, i + concurrencyLimit)
      const chunkPromises = chunk.map(async (batch, chunkIndex) => {
        const batchIndex = i + chunkIndex
        const batchData = generateBatchText(batch, username)

        try {
          const batchSummary = await callOpenAIForBatch(
            batchData,
            batchIndex + 1,
            batches.length,
            username
          )
          return { index: batchIndex, summary: batchSummary }
        } catch (error) {
          console.error(
            `‚ùå Failed to process batch ${batchIndex + 1}, skipping...`
          )
          return {
            index: batchIndex,
            summary: `Batch ${batchIndex + 1} analysis failed: ${
              error instanceof Error ? error.message : String(error)
            }`,
          }
        }
      })

      const chunkResults = await Promise.all(chunkPromises)

      chunkResults.forEach(({ index, summary }) => {
        batchSummaries[index] = summary
      })

      if (i + concurrencyLimit < batches.length) {
        await new Promise((resolve) => setTimeout(resolve, 1000))
      }
    }

    const totalStats = {
      prs: 0, // Always 0 since we're only processing commits
      commits: result.commits.length,
      mergedPRs: 0, // Not applicable for commits
    }

    const aiSummary = await callOpenAIForFinalSummary(
      batchSummaries,
      username,
      startDate,
      endDate,
      totalStats
    )

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const filename = `contribution-summary-${username}-${startDate}-to-${endDate}-${timestamp}.md`
    const filepath = join(__dirname, '../generated', filename)

    const report = `# GitHub Contribution Summary

**Developer:** ${username}  
**Period:** ${startDate} to ${endDate}  
**Generated:** ${new Date().toLocaleString()}  
**Analysis Method:** Batched AI Analysis (${batches.length} batches processed)

---

## Comprehensive Summary

${aiSummary}

---

## Raw Contribution Data

${fullContributionData}
`
    writeFileSync(filepath, report, 'utf8')

    console.log(`\n‚úÖ Summary saved to: ${filepath}`)
    console.log(`üìä AI Analysis completed successfully!`)
  } catch (error) {
    console.error('‚ùå Error generating summary:', error)
    throw error
  }
}

async function main() {
  try {
    const args = process.argv.slice(2)

    if (args.length < 3) {
      console.log(
        'Usage: ts-node contribution-summary.ts <username> <start-date> <end-date> [--export|--ai]'
      )
      console.log('Date format: YYYY-MM-DD')
      console.log('--export: Save raw GitHub data to generated/ folder')
      console.log('--ai: Generate AI summary and save to generated/ folder')
      process.exit(1)
    }

    const [username, startDate, endDate, flag] = args
    const exportFormat = flag === '--export'
    const aiSummary = flag === '--ai'

    if (aiSummary && !OPENAI_API_KEY) {
      throw new Error(
        'OPENAI_API_KEY environment variable is required for AI summary'
      )
    }

    const dateRegex = /^\d{4}-\d{2}-\d{2}$/
    if (!dateRegex.test(startDate) || !dateRegex.test(endDate)) {
      console.error('‚ùå Invalid date format. Please use YYYY-MM-DD format.')
      process.exit(1)
    }

    if (new Date(startDate) > new Date(endDate)) {
      console.error('‚ùå Start date must be before end date.')
      process.exit(1)
    }

    const result = await getContributionSummary(username, startDate, endDate)

    if (aiSummary) {
      // Generate AI summary and save to file
      await generateAndSaveSummary(result, username, startDate, endDate)
    } else if (exportFormat) {
      // Save raw GitHub data to file
      saveExportData(result, username, startDate, endDate)
    } else {
      // Display results in terminal
      displayResults(result, username, false)
    }
  } catch (error) {
    console.error(
      '‚ùå Error:',
      error instanceof Error ? error.message : String(error)
    )
    process.exit(1)
  }
}

// Run the script if called directly
if (require.main === module) {
  main()
}

export {
  getContributionSummary,
  generateAndSaveSummary,
  displayResults,
  saveExportData,
  searchCommits,
}
