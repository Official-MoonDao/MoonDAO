{"abi":[{"type":"function","name":"claimId","inputs":[{"name":"user","type":"address","internalType":"address"},{"name":"context","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"","type":"bytes32","internalType":"bytes32"}],"stateMutability":"view"},{"type":"function","name":"isEligible","inputs":[{"name":"user","type":"address","internalType":"address"},{"name":"context","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"eligible","type":"bool","internalType":"bool"},{"name":"xpAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"name","inputs":[],"outputs":[{"name":"","type":"string","internalType":"string"}],"stateMutability":"view"},{"type":"function","name":"validAfter","inputs":[{"name":"user","type":"address","internalType":"address"},{"name":"context","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"claimId(address,bytes)":"4e3c1509","isEligible(address,bytes)":"5dcbc01b","name()":"06fdde03","validAfter(address,bytes)":"61d01335"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"claimId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"isEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"eligible\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"xpAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"validAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Intended to be called by an XPManager. Stateless verifiers are ideal,      but implementations may read external contracts (ERC20/721/1155, etc.).\",\"kind\":\"dev\",\"methods\":{\"claimId(address,bytes)\":{\"details\":\"XPManager should mark this as consumed to prevent re-claims.      MUST be stable across calls and independent of current eligibility.      Recommended: keccak256(abi.encodePacked(address(this), user, contextCanonicalForm)).\",\"params\":{\"context\":\"Same bytes passed to isEligible.\",\"user\":\"The claimant.\"},\"returns\":{\"_0\":\"id A unique claim identifier.\"}},\"isEligible(address,bytes)\":{\"details\":\"MUST be a pure/read-only check (no state writes).\",\"params\":{\"context\":\"ABI-encoded parameters the verifier needs (e.g., nft addr, min balance, snapshot id).        Examples:          - abi.encode(address nftAddress, uint256 minBalance)          - abi.encode(address token, uint256 minAmount, uint256 blockNumber)\",\"user\":\"The claimant.\"},\"returns\":{\"eligible\":\"True if user currently satisfies the condition.\",\"xpAmount\":\"How much XP should be granted if eligible (0 allowed).\"}},\"validAfter(address,bytes)\":{\"details\":\"Return 0 if the verifier has no cooldown concept. XPManager can ignore if not used.\",\"params\":{\"context\":\"Same bytes passed to isEligible.\",\"user\":\"The claimant.\"},\"returns\":{\"_0\":\"validAfter Unix timestamp after which a new claim may be attempted.\"}}},\"title\":\"IXPVerifier\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"claimId(address,bytes)\":{\"notice\":\"Deterministic ID for this specific (user, context) claim.\"},\"isEligible(address,bytes)\":{\"notice\":\"Check if `user` meets the condition described by `context`.\"},\"name()\":{\"notice\":\"Human-readable identifier for this verifier (e.g., \\\"OwnsCoolNFT:v1\\\").\"},\"validAfter(address,bytes)\":{\"notice\":\"Optional: cooldown timestamp after which the user may claim again.\"}},\"notice\":\"Pluggable eligibility checker for XP claims.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/interfaces/IXPVerifier.sol\":\"IXPVerifier\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@chainlink/=lib/contracts/lib/chainlink/\",\":@ds-test/=lib/contracts/lib/ds-test/src/\",\":@openzeppelin/contracts-upgradeable/=lib/contracts/lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":@rari-capital/solmate/=lib/contracts/lib/seaport/lib/solmate/\",\":@seaport/=lib/contracts/lib/seaport/contracts/\",\":@solady/=lib/contracts/lib/solady/\",\":@std/=lib/contracts/lib/forge-std/src/\",\":@thirdweb-dev/dynamic-contracts/=lib/contracts/lib/dynamic-contracts/\",\":ERC721A-Upgradeable/=lib/contracts/lib/ERC721A-Upgradeable/contracts/\",\":ERC721A/=lib/contracts/lib/ERC721A/contracts/\",\":chainlink/=lib/contracts/lib/chainlink/contracts/\",\":contracts/=lib/contracts/contracts/\",\":ds-test/=lib/contracts/lib/ds-test/src/\",\":dynamic-contracts/=lib/contracts/lib/dynamic-contracts/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":erc721a-upgradeable/=lib/contracts/lib/ERC721A-Upgradeable/\",\":erc721a/=lib/contracts/lib/ERC721A/\",\":forge-std/=lib/forge-std/src/\",\":halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\":lib/sstore2/=lib/contracts/lib/dynamic-contracts/lib/sstore2/\",\":murky/=lib/contracts/lib/murky/src/\",\":openzeppelin-contracts-upgradeable/=lib/contracts/lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/contracts/lib/openzeppelin-contracts-upgradeable/contracts/\",\":seaport-core/=lib/contracts/lib/seaport-core/src/\",\":seaport-sol/=lib/contracts/lib/seaport-sol/src/\",\":seaport-types/=lib/contracts/lib/seaport-types/src/\",\":seaport/=lib/contracts/lib/seaport/\",\":solady/=lib/contracts/lib/solady/src/\",\":solarray/=lib/contracts/lib/seaport/lib/solarray/src/\",\":solmate/=lib/contracts/lib/seaport/lib/solmate/src/\",\":sstore2/=lib/contracts/lib/dynamic-contracts/lib/sstore2/contracts/\"]},\"sources\":{\"src/interfaces/IXPVerifier.sol\":{\"keccak256\":\"0xc431e214d3e820111a2ce6153c892580f1656080f76644012eb145fdd43092c5\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://22fdae3a17b082774341e65fd7333f8117e06580064f19aef5fa2d2eb42ea9a1\",\"dweb:/ipfs/Qmd6rwj3xzTWgB83ydwi73PGYwZLnwvrRWdNU7UnmZGhQm\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.28+commit.7893614a"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"bytes","name":"context","type":"bytes"}],"stateMutability":"view","type":"function","name":"claimId","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}]},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"bytes","name":"context","type":"bytes"}],"stateMutability":"view","type":"function","name":"isEligible","outputs":[{"internalType":"bool","name":"eligible","type":"bool"},{"internalType":"uint256","name":"xpAmount","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"name","outputs":[{"internalType":"string","name":"","type":"string"}]},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"bytes","name":"context","type":"bytes"}],"stateMutability":"view","type":"function","name":"validAfter","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]}],"devdoc":{"kind":"dev","methods":{"claimId(address,bytes)":{"details":"XPManager should mark this as consumed to prevent re-claims.      MUST be stable across calls and independent of current eligibility.      Recommended: keccak256(abi.encodePacked(address(this), user, contextCanonicalForm)).","params":{"context":"Same bytes passed to isEligible.","user":"The claimant."},"returns":{"_0":"id A unique claim identifier."}},"isEligible(address,bytes)":{"details":"MUST be a pure/read-only check (no state writes).","params":{"context":"ABI-encoded parameters the verifier needs (e.g., nft addr, min balance, snapshot id).        Examples:          - abi.encode(address nftAddress, uint256 minBalance)          - abi.encode(address token, uint256 minAmount, uint256 blockNumber)","user":"The claimant."},"returns":{"eligible":"True if user currently satisfies the condition.","xpAmount":"How much XP should be granted if eligible (0 allowed)."}},"validAfter(address,bytes)":{"details":"Return 0 if the verifier has no cooldown concept. XPManager can ignore if not used.","params":{"context":"Same bytes passed to isEligible.","user":"The claimant."},"returns":{"_0":"validAfter Unix timestamp after which a new claim may be attempted."}}},"version":1},"userdoc":{"kind":"user","methods":{"claimId(address,bytes)":{"notice":"Deterministic ID for this specific (user, context) claim."},"isEligible(address,bytes)":{"notice":"Check if `user` meets the condition described by `context`."},"name()":{"notice":"Human-readable identifier for this verifier (e.g., \"OwnsCoolNFT:v1\")."},"validAfter(address,bytes)":{"notice":"Optional: cooldown timestamp after which the user may claim again."}},"version":1}},"settings":{"remappings":["@chainlink/=lib/contracts/lib/chainlink/","@ds-test/=lib/contracts/lib/ds-test/src/","@openzeppelin/contracts-upgradeable/=lib/contracts/lib/openzeppelin-contracts-upgradeable/contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@rari-capital/solmate/=lib/contracts/lib/seaport/lib/solmate/","@seaport/=lib/contracts/lib/seaport/contracts/","@solady/=lib/contracts/lib/solady/","@std/=lib/contracts/lib/forge-std/src/","@thirdweb-dev/dynamic-contracts/=lib/contracts/lib/dynamic-contracts/","ERC721A-Upgradeable/=lib/contracts/lib/ERC721A-Upgradeable/contracts/","ERC721A/=lib/contracts/lib/ERC721A/contracts/","chainlink/=lib/contracts/lib/chainlink/contracts/","contracts/=lib/contracts/contracts/","ds-test/=lib/contracts/lib/ds-test/src/","dynamic-contracts/=lib/contracts/lib/dynamic-contracts/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","erc721a-upgradeable/=lib/contracts/lib/ERC721A-Upgradeable/","erc721a/=lib/contracts/lib/ERC721A/","forge-std/=lib/forge-std/src/","halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/","lib/sstore2/=lib/contracts/lib/dynamic-contracts/lib/sstore2/","murky/=lib/contracts/lib/murky/src/","openzeppelin-contracts-upgradeable/=lib/contracts/lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/contracts/lib/openzeppelin-contracts-upgradeable/contracts/","seaport-core/=lib/contracts/lib/seaport-core/src/","seaport-sol/=lib/contracts/lib/seaport-sol/src/","seaport-types/=lib/contracts/lib/seaport-types/src/","seaport/=lib/contracts/lib/seaport/","solady/=lib/contracts/lib/solady/src/","solarray/=lib/contracts/lib/seaport/lib/solarray/src/","solmate/=lib/contracts/lib/seaport/lib/solmate/src/","sstore2/=lib/contracts/lib/dynamic-contracts/lib/sstore2/contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"src/interfaces/IXPVerifier.sol":"IXPVerifier"},"evmVersion":"cancun","libraries":{}},"sources":{"src/interfaces/IXPVerifier.sol":{"keccak256":"0xc431e214d3e820111a2ce6153c892580f1656080f76644012eb145fdd43092c5","urls":["bzz-raw://22fdae3a17b082774341e65fd7333f8117e06580064f19aef5fa2d2eb42ea9a1","dweb:/ipfs/Qmd6rwj3xzTWgB83ydwi73PGYwZLnwvrRWdNU7UnmZGhQm"],"license":"MIT"}},"version":1},"id":49}